{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "canvas.svelte",
    "gate.svelte",
    "input.svelte",
    "light.svelte",
    "output.svelte",
    "userInput.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n\timport { onMount } from 'svelte';\r\n\timport Canvas from './canvas.svelte';\r\n\r\n\tlet canvas;\r\n\r\n\tonMount(async () => {\r\n        document.addEventListener('contextmenu', event => event.preventDefault());       \r\n    });\r\n\r\n\tfunction handleClick() {\r\n\t\talert(\"pressed\");\r\n\t}\r\n</script>\r\n\r\n<style>\r\n\tbutton {\r\n\t\twidth: 90%;\r\n\t\tmargin: 5%;\r\n\t}\r\n\t.main {\r\n\t\twidth: 100%;\r\n\t\theight: 100%; \r\n\t\toverflow: hidden;\r\n\t}\r\n\t.menu {\r\n\t\twidth: 85px; \r\n\t\tfloat: left; \r\n\t\theight: 100%; \r\n\t\tbackground-color: white;\r\n\t\tz-index: 1;\r\n\t\tposition: relative;\r\n\t}\r\n\t.canvas {\r\n\t\tmargin-left: 85px; \r\n\t\theight: 100%;\r\n\t}\r\n</style>\r\n\r\n<div class=\"main\">\r\n\t<div class=\"menu\">\r\n\t\t<button on:click={() => canvas.addGate(\"AND\")}>AND</button>\r\n\t\t<button on:click={() => canvas.addGate(\"NAND\")}>NAND</button>\r\n\t\t<button on:click={() => canvas.addGate(\"OR\")}>OR</button>\r\n\t\t<button on:click={() => canvas.addGate(\"NOR\")}>NOR</button>\r\n\t\t<button on:click={() => canvas.addGate(\"XOR\")}>XOR</button>\r\n\t\t<button on:click={() => canvas.addGate(\"NOT\")}>NOT</button>\r\n\t\t<button on:click={() => canvas.addGate(\"1\")}>1</button>\r\n\t\t<button on:click={() => canvas.addGate(\"0\")}>0</button>\r\n\t\t<button on:click={() => canvas.addGate(\"Logic_Button\")}>Switch</button>\r\n\t\t<button on:click={() => canvas.addGate(\"Light\")}>Light</button>\r\n\t\t<button on:click={() => canvas.debugGates()}>DEBUG</button>\r\n\t\t<button on:click={() => canvas.simulatate()}>PLAY</button>\r\n\t</div>\r\n\t<div class=\"canvas\">\r\n\t\t<Canvas bind:this={canvas}/>\r\n\t</div>\r\n</div>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n    import Gate from './gate.svelte';\r\n    import UserInput from './userInput.svelte';\r\n    import Wire from './wire.svelte';\r\n    import { NAND } from './js/gates.js'\r\n    import { evaluate } from './js/newSim.js'\r\n    import Light from './light.svelte';\r\n\r\n    class Vector {\r\n        constructor(x, y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        add(v) {\r\n            this.x += v.x;\r\n            this.y += v.y;\r\n        }\r\n        sub(v) {\r\n            this.x -= v.x;\r\n            this.y -= v.y;\r\n        }\r\n        scale(n) {\r\n            this.x *= n;\r\n            this.y *= n;\r\n        }\r\n    };\r\n\r\n    const indexBy = (array, prop) => array.reduce((output, item) => {\r\n        output[item[prop]] = item;\r\n        return output;\r\n    }, {});\r\n\r\n    let components = [\r\n\r\n    ];\r\n\r\n    let gates = [\r\n        //{ id: '0', position: new Vector(64,32),  image: \"./build/AND_GATE.svg\", gate: new NAND() },\r\n        //{ id: '1', position: new Vector(128,0), image: \"./build/AND_GATE.svg\",  gate: new NAND() }\r\n    ];\r\n\r\n    let wires = [\r\n        \r\n    ];\r\n\r\n    let nextGateID = 0;\r\n\r\n    let mousePosition;\r\n    let workspaceDom;\r\n    let zoomLayerDom;\r\n\r\n    let gridSpacing;\r\n\r\n    let isPlacing = false;\r\n    let placingGate;\r\n    let placingComponent;\r\n\r\n    let scale = 1;\r\n    let screenPos = new Vector(0, 0);\r\n    let isGrabbing = false;\r\n    let begGrabPos;\r\n    let endGrabPos;\r\n\r\n    onMount(async () => {\r\n        //Call the update function on all the gates that already exist\r\n    });\r\n\r\n    function mouseDown(event) {\r\n        //Placing a gate\r\n        if (isPlacing) {\r\n            //Add to list of gates\r\n            gates = [...gates, placingGate];\r\n            isPlacing = false;\r\n            //Add gate to componets array\r\n            components = [...components, placingComponent];\r\n        }\r\n        if (event.button === 2) {\r\n            //Moving around the workspace\r\n            isGrabbing = true;\r\n            begGrabPos = new Vector(event.pageX, event.pageY);\r\n        }\r\n    }\r\n    function mouseUp(event) {\r\n        if (event.button === 2) {\r\n            //Moving around the workspace\r\n            isGrabbing = false;\r\n            endGrabPos = new Vector(event.pageX, event.pageY);\r\n\r\n            begGrabPos.sub(endGrabPos);\r\n            screenPos.sub(begGrabPos);\r\n\r\n            document.getElementById(\"zoomLayer\").style.left = screenPos.x + \"px\";\r\n            document.getElementById(\"zoomLayer\").style.top = screenPos.y + \"px\";\r\n        }\r\n    }\r\n    function mouseMove(event) {\r\n        //Keep mouse position\r\n        mousePosition = new Vector(event.pageX, event.pageY);\r\n        //Move the gate being placed to the cursor when the mouse moves\r\n        if (isPlacing) {\r\n            //Lock to grid movement\r\n            let zoomLayerOffset = offset(zoomLayerDom);\r\n            zoomLayerOffset.left *= (1/scale);\r\n            zoomLayerOffset.top *= (1/scale);\r\n            let gatePos = new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top);\r\n            placingGate.position = new Vector(Math.round((gatePos.x / 32) - 0.5) * 32, Math.round((gatePos.y / 32) - 0.5) * 32);\r\n        }\r\n        //Move the wire being placed\r\n        if (isWire) {\r\n            let zoomLayerOffset = offset(zoomLayerDom);\r\n            zoomLayerOffset.left *= (1/scale);\r\n            zoomLayerOffset.top *= (1/scale);\r\n            let wirePos = new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top);\r\n            placingWire.endPos = new Vector(wirePos.x, wirePos.y);\r\n        }\r\n        //Moving around the workspace\r\n        if (isGrabbing) {\r\n            endGrabPos = new Vector(event.pageX, event.pageY);\r\n\r\n            var begGrabCopy = new Vector(begGrabPos.x, begGrabPos.y);\r\n\r\n            begGrabCopy.sub(endGrabPos);\r\n            screenPos.sub(begGrabCopy);\r\n\r\n            document.getElementById(\"zoomLayer\").style.left = screenPos.x + \"px\";\r\n            document.getElementById(\"zoomLayer\").style.top = screenPos.y + \"px\";\r\n\r\n            begGrabPos = new Vector(endGrabPos.x, endGrabPos.y);\r\n        }\r\n    }\r\n    \r\n    function keypressing(event) {\r\n        if (event.key === '=') { //Plus key\r\n            if (scale < 3)\r\n                scale += 0.25;\r\n        }\r\n        else if (event.key === '-') { //Minus key\r\n            if (scale > 0.25)\r\n                scale -= 0.25;\r\n        }\r\n        document.getElementById(\"zoomLayer\").style.transform = \"scale(\" + scale + \")\";\r\n    }\r\n\r\n    export function addGate(gateType) {\r\n        let zoomLayerOffset = offset(zoomLayerDom);\r\n        zoomLayerOffset.left *= (1/scale);\r\n        zoomLayerOffset.top *= (1/scale);\r\n\r\n        switch (gateType) {\r\n        case \"AND\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/NEW_AND.svg\",\r\n                inputs: 2,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'and',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"NAND\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/NEW_NAND.svg\",\r\n                inputs: 2,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'nand',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"0\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/AND_GATE.svg\",\r\n                inputs: 0,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'controlled',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"1\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/AND_GATE.svg\",\r\n                inputs: 0,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'controlled',\r\n                inputs: [],\r\n                state: 1,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"Logic_Button\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/AND_GATE.svg\",\r\n                inputs: 0,\r\n                outputs: 1,\r\n                logic_button: 1,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'controlled',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"Light\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/Light.svg\",\r\n                inputs: 1,\r\n                outputs: 0,\r\n                logic_button: 2,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'equal',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"OR\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/OR_GATE.svg\",\r\n                inputs: 2,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'or',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"XOR\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/XOR_GATE.svg\",\r\n                inputs: 2,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'xor',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"NOT\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/NOT_GATE.svg\",\r\n                inputs: 1,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'not',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        case \"NOR\":\r\n            placingGate = { \r\n                id: nextGateID.toString(),\r\n                position: new Vector((1/scale) * event.pageX - zoomLayerOffset.left, (1/scale) * event.pageY - zoomLayerOffset.top), \r\n                image: \"./build/NOR_GATE.svg\",\r\n                inputs: 2,\r\n                outputs: 1,\r\n                logic_button: 0,\r\n                state: 0\r\n            }\r\n            placingComponent = {\r\n                id: nextGateID.toString(),\r\n                type: 'nor',\r\n                inputs: [],\r\n                state: 0,\r\n            }\r\n            isPlacing = true;\r\n            nextGateID++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    function getComponent(id) \r\n    {\r\n        for (let i = 0; i < components.length; i++) { \r\n            if (components[i].id === id) {\r\n                return components[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    let isWire = false;\r\n    let placingWire;\r\n    let outputID;\r\n\r\n    export function outputCallback(x_pos, y_pos, id) {\r\n        console.log(\"Output callback\");\r\n        isWire = true;\r\n        outputID = id;\r\n        let internalState = getComponent(id).state;\r\n        placingWire = {\r\n            startPos: new Vector(x_pos, y_pos),\r\n            endPos: new Vector(x_pos, y_pos),\r\n            id: id,\r\n            state: internalState //Should be 'x'?\r\n        };\r\n    }\r\n\r\n    export function inputCallback(x_pos, y_pos, inWireIndex, id) {\r\n        console.log(\"Input callback\");\r\n        if (isWire) {\r\n            isWire = false;\r\n            placingWire.endPos = new Vector(x_pos, y_pos);\r\n            wires = [...wires, placingWire];\r\n            //Connect components in the array\r\n            for (let i = 0; i < components.length; i++) { \r\n                if (components[i].id === id) {\r\n                    components[i].inputs.push(outputID);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export function debugGates() {\r\n        //Print info about all gates\r\n        console.log(\"Gate debug:\");\r\n        console.log(\"Components Array: \");\r\n        console.log(components);\r\n    }\r\n\r\n    export function simulatate() {\r\n        //Idk does something lol\r\n        const componentLookup = indexBy(components, 'id');\r\n        //Run for 1 step\r\n        for (let iteration = 0; iteration < 1; iteration++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                evaluate(components, componentLookup);\r\n            }\r\n        }\r\n        //Update wire states for rendering purpose (Inefficent temp code)\r\n        for (let w = 0; w < wires.length; w++) { \r\n            for (let i = 0; i < components.length; i++) { \r\n                if (components[i].id === wires[w].id) {\r\n                    wires[w].state = components[i].state;\r\n                }\r\n            }\r\n        }\r\n        //Update gate states for rendering purpose (Inefficent temp code)\r\n        for (let w = 0; w < gates.length; w++) { \r\n            for (let i = 0; i < components.length; i++) { \r\n                if (components[i].id === gates[w].id) {\r\n                    gates[w].state = components[i].state;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function switchState(id) {\r\n        console.log(\"Called\");\r\n        let comp = getComponent(id);\r\n        if (comp.state)\r\n            comp.state = 0;\r\n        else\r\n            comp.state = 1;\r\n        //Rerun sim\r\n        simulatate();\r\n    }\r\n\r\n    function offset(el) {\r\n        var rect = el.getBoundingClientRect(),\r\n        scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\r\n        scrollTop = window.pageYOffset || document.documentElement.scrollTop;\r\n        return { top: rect.top + scrollTop, left: rect.left + scrollLeft }\r\n    }\r\n\r\n</script>\r\n\r\n<style>\r\n\tdiv {\r\n        width: 100%;\r\n        height: 100%;\r\n\r\n        position: relative;\r\n\r\n        transform: scale(1);\r\n    }\r\n    .workspace {\r\n        background-color: #d6d6d6;\r\n    }\r\n    #zoomLayer {\r\n        background-image: url(./grid.png);\r\n        width: 2048px;\r\n        height: 2048px;\r\n    }\r\n    .wire {\r\n        position: relative;\r\n        z-index: -2;\r\n    }\r\n</style>\r\n\r\n<svelte:window on:mousedown={mouseDown} on:mouseup={mouseUp} on:mousemove={mouseMove} on:keypress={keypressing}/>\r\n\r\n<div class=\"workspace\" bind:this={workspaceDom}>\r\n    <div id=\"zoomLayer\" bind:this={zoomLayerDom}>\r\n        <div class=\"wire\">\r\n            <svg width=\"2048\" height=\"2048\">\r\n                {#each wires as wire, i}\r\n                    <Wire start_x_pos={wires[i].startPos.x} start_y_pos={wires[i].startPos.y}\r\n                        end_x_pos={wires[i].endPos.x} end_y_pos={wires[i].endPos.y} state={wires[i].state}\r\n                    />\r\n                {/each}\r\n                {#if isWire}\r\n                    <Wire start_x_pos={placingWire.startPos.x} start_y_pos={placingWire.startPos.y}\r\n                        end_x_pos={placingWire.endPos.x} end_y_pos={placingWire.endPos.y} state={placingWire.state}\r\n                    />\r\n                {/if}\r\n            </svg>\r\n        </div>\r\n        {#each gates as gate, i}\r\n            {#if gates[i].logic_button === 1}\r\n                <UserInput x_pos={gates[i].position.x} y_pos={gates[i].position.y} image={gates[i].image}\r\n                    outputs={gates[i].outputs} id={gates[i].id} outputCallback={outputCallback} switchState={switchState}\r\n                />\r\n            {:else if gates[i].logic_button === 2}\r\n                <Light x_pos={gates[i].position.x} y_pos={gates[i].position.y} image={gates[i].image}\r\n                    outputs={gates[i].outputs} id={gates[i].id} inputCallback={inputCallback} state={gates[i].state}\r\n                />\r\n            {:else}\r\n                <Gate x_pos={gates[i].position.x} y_pos={gates[i].position.y}\r\n                    image={gates[i].image} inputs={gates[i].inputs} outputs={gates[i].outputs} id={gates[i].id}\r\n                    outputCallback={outputCallback} inputCallback={inputCallback}\r\n                />\r\n            {/if}\r\n        {/each}\r\n        {#if isPlacing}\r\n            {#if isPlacing.logic_button === 1}\r\n                <UserInput x_pos={placingGate.position.x} y_pos={placingGate.position.y} image={placingGate.image}\r\n                    outputs={placingGate.outputs} id={placingGate.id} switchState={switchState}\r\n                />\r\n            {:else if placingGate.logic_button === 2}\r\n                <Light x_pos={placingGate.position.x} y_pos={placingGate.position.y} image={placingGate.image}\r\n                    outputs={placingGate.outputs} id={placingGate.id} inputCallback={inputCallback}\r\n                />\r\n            {:else}\r\n                <Gate x_pos={placingGate.position.x} y_pos={placingGate.position.y} image={placingGate.image}\r\n                    inputs={placingGate.inputs} outputs={placingGate.outputs} id={placingGate.id}\r\n                />\r\n            {/if}\r\n        {/if}\r\n    </div>\r\n</div>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n    import Input from './input.svelte';\r\n    import Output from './output.svelte';\r\n\r\n    export let x_pos = 0;\r\n    export let y_pos = 0;\r\n    export let image;\r\n\r\n    export let inputCallback;\r\n    export let outputCallback;\r\n\r\n    export let inputs;\r\n    export let outputs;\r\n    export let id;\r\n\r\n    let dom;\r\n\r\n    onMount(async () => {\r\n        //Move to position assigned by the creator on startup\r\n\t\tdom.style.left = x_pos + \"px\";\r\n        dom.style.top = y_pos + \"px\";\r\n        dom.style.backgroundImage = \"url(\" + image + \")\";     \r\n    });\r\n\r\n    function updatePosition() {\r\n        if (dom) {\r\n            dom.style.left = x_pos + \"px\";\r\n            dom.style.top = y_pos + \"px\";\r\n        }\r\n    }\r\n\r\n    //Called whenever x or y position is updated externally from parent or internally\r\n    $: if (x_pos || y_pos) {\r\n        updatePosition();\r\n    } \r\n\r\n</script>\r\n\r\n<style>\r\n\tdiv {\r\n        width: 32px;\r\n        height: 32px;\r\n        background-repeat: no-repeat;\r\n        position: absolute;\r\n        z-index: -1;\r\n    }\r\n</style>\r\n\r\n<div bind:this={dom}>\r\n    {#each Array(inputs) as _, i}\r\n        <Input x_pos={-26} y_pos={i * 16} wireIndex={i} id={id} inputCallback={inputCallback}/>\r\n    {/each}\r\n    {#each Array(outputs) as _, i}\r\n        <Output x_pos={42} y_pos={7} id={id} outputCallback={outputCallback}/>\r\n    {/each}\r\n</div>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n    import { Wire } from './js/gates.js'\r\n\r\n    export let x_pos = 0;\r\n    export let y_pos = 0;\r\n\r\n    export let wireIndex;\r\n    export let id;\r\n\r\n    export let inputCallback;\r\n\r\n    let line_dom;\r\n    let circle_dom;\r\n\r\n    onMount(async () => {\r\n\t\tcircle_dom.style.left = x_pos + \"px\";\r\n        circle_dom.style.top = y_pos + \"px\";\r\n        circle_dom.style.backgroundImage = \"url(build/PORT_CIRCLE.svg)\";\r\n\r\n        line_dom.style.left = x_pos + 11 + \"px\";\r\n        line_dom.style.top = y_pos + 7 + \"px\";\r\n        line_dom.style.backgroundImage = \"url(build/PORT_LINE.svg)\";\r\n    });\r\n\r\n    function hoving(event) {\r\n        circle_dom.style.transform = \"scale(\" + 1.5 + \")\";\r\n    }\r\n    function leaveing() {\r\n        circle_dom.style.transform = \"scale(\" + 1 + \")\";\r\n    }\r\n    function mouseDown() {\r\n        let temp = circle_dom.parentNode.style;\r\n        inputCallback(x_pos + parseInt(temp.left) + 8, y_pos + parseInt(temp.top) + 8, wireIndex, id);\r\n    }\r\n\r\n</script>\r\n\r\n<style>\r\n\tdiv {\r\n        width: 16px;\r\n        height: 16px;\r\n        /* background-image: url(./PORT.svg); */\r\n        background-repeat: no-repeat;\r\n        position: absolute;\r\n        z-index: -1;\r\n    }\r\n    .line {\r\n        width: 16px;\r\n        height: 3px;\r\n    }\r\n</style>\r\n\r\n<div class=\"line\" bind:this={line_dom}>\r\n</div>\r\n<div class=\"port\" bind:this={circle_dom} on:mouseover={hoving} on:mouseout={leaveing} on:mousedown={mouseDown}>\r\n</div>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n    import Input from './input.svelte';\r\n\r\n    export let x_pos = 0;\r\n    export let y_pos = 0;\r\n    export let image;\r\n\r\n    export let inputCallback;\r\n\r\n    export let state;\r\n    export let inputs;\r\n    export let id;\r\n\r\n    let dom;\r\n\r\n    onMount(async () => {\r\n        //Move to position assigned by the creator on startup\r\n\t\tdom.style.left = x_pos + \"px\";\r\n        dom.style.top = y_pos + \"px\";\r\n        dom.style.backgroundImage = \"url(\" + image + \")\";     \r\n    });\r\n\r\n    function updatePosition() {\r\n        if (dom) {\r\n            dom.style.left = x_pos + \"px\";\r\n            dom.style.top = y_pos + \"px\";\r\n        }\r\n    }\r\n\r\n    $: if (state) {\r\n        dom.style.backgroundColor = 'blue';\r\n    }\r\n    else {\r\n        if (dom !== undefined)\r\n            dom.style.backgroundColor = 'white';\r\n    }\r\n\r\n    //Called whenever x or y position is updated externally from parent or internally\r\n    $: if (x_pos || y_pos) {\r\n        updatePosition();\r\n    }\r\n\r\n</script>\r\n\r\n<style>\r\n\tdiv {\r\n        background-color: blue;\r\n        width: 32px;\r\n        height: 32px;\r\n        background-repeat: no-repeat;\r\n        position: absolute;\r\n        z-index: -1;\r\n    }\r\n</style>\r\n\r\n<div bind:this={dom}>\r\n    {#each Array(inputs) as _, i}\r\n        <Input x_pos={-26} y_pos={i * 16} wireIndex={i} id={id} inputCallback={inputCallback}/>\r\n    {/each}\r\n</div>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n    import { Wire } from './js/gates.js'\r\n\r\n    export let x_pos = 0;\r\n    export let y_pos = 0;\r\n\r\n    export let id;\r\n\r\n    export let outputCallback;\r\n\r\n    let line_dom;\r\n    let circle_dom;\r\n\r\n    onMount(async () => {\r\n\t\tcircle_dom.style.left = x_pos + \"px\";\r\n        circle_dom.style.top = y_pos + \"px\";\r\n        circle_dom.style.backgroundImage = \"url(build/PORT_CIRCLE.svg)\";\r\n\r\n        line_dom.style.left = x_pos - 11 + \"px\";\r\n        line_dom.style.top = y_pos + 7 + \"px\";\r\n        line_dom.style.backgroundImage = \"url(build/PORT_LINE.svg)\";\r\n    });\r\n\r\n    function hoving(event) {\r\n        circle_dom.style.transform = \"scale(\" + 1.5 + \")\";\r\n    }\r\n    function leaveing() {\r\n        circle_dom.style.transform = \"scale(\" + 1 + \")\";\r\n    }\r\n    function mouseDown() {\r\n        let temp = circle_dom.parentNode.style;\r\n        outputCallback(x_pos + parseInt(temp.left) + 8, y_pos + parseInt(temp.top) + 8, id);\r\n    }\r\n\r\n</script>\r\n\r\n<style>\r\n\tdiv {\r\n        width: 16px;\r\n        height: 16px;\r\n        /* background-image: url(./PORT.svg); */\r\n        background-repeat: no-repeat;\r\n        position: absolute;\r\n        z-index: -1;\r\n    }\r\n    .line {\r\n        width: 16px;\r\n        height: 3px;\r\n    }\r\n</style>\r\n\r\n<div class=\"line\" bind:this={line_dom}>\r\n</div>\r\n<div class=\"port\" bind:this={circle_dom} on:mouseover={hoving} on:mouseout={leaveing} on:mousedown={mouseDown}>\r\n</div>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n    import Output from './output.svelte';\r\n\r\n    export let x_pos = 0;\r\n    export let y_pos = 0;\r\n    export let image;\r\n\r\n    export let outputCallback;\r\n\r\n    export let switchState;\r\n    export let outputs;\r\n    export let id;\r\n\r\n    let dom;\r\n\r\n    onMount(async () => {\r\n        //Move to position assigned by the creator on startup\r\n\t\tdom.style.left = x_pos + \"px\";\r\n        dom.style.top = y_pos + \"px\";\r\n        dom.style.backgroundImage = \"url(\" + image + \")\";     \r\n    });\r\n\r\n    function updatePosition() {\r\n        if (dom) {\r\n            dom.style.left = x_pos + \"px\";\r\n            dom.style.top = y_pos + \"px\";\r\n        }\r\n    }\r\n\r\n    //Called whenever x or y position is updated externally from parent or internally\r\n    $: if (x_pos || y_pos) {\r\n        updatePosition();\r\n    }\r\n\r\n    function mouseDown() {\r\n        //Change state\r\n        switchState(id);\r\n    }\r\n\r\n</script>\r\n\r\n<style>\r\n\tdiv {\r\n        width: 32px;\r\n        height: 32px;\r\n        background-repeat: no-repeat;\r\n        position: absolute;\r\n        z-index: -1;\r\n    }\r\n</style>\r\n\r\n<div bind:this={dom} on:mousedown={mouseDown}>\r\n    {#each Array(outputs) as _, i}\r\n        <Output x_pos={42} y_pos={7} id={id} outputCallback={outputCallback}/>\r\n    {/each}\r\n</div>"
  ],
  "names": [],
  "mappings": "AAgBC,MAAM,eAAC,CAAC,AACP,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,EAAE,AACX,CAAC,AACD,KAAK,eAAC,CAAC,AACN,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,AACjB,CAAC,AACD,KAAK,eAAC,CAAC,AACN,KAAK,CAAE,IAAI,CACX,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,KAAK,CACvB,OAAO,CAAE,CAAC,CACV,QAAQ,CAAE,QAAQ,AACnB,CAAC,AACD,OAAO,eAAC,CAAC,AACR,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,IAAI,AACb,CAAC;ACmZD,GAAG,eAAC,CAAC,AACE,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CAEZ,QAAQ,CAAE,QAAQ,CAElB,SAAS,CAAE,MAAM,CAAC,CAAC,AACvB,CAAC,AACD,UAAU,eAAC,CAAC,AACR,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AACD,UAAU,eAAC,CAAC,AACR,gBAAgB,CAAE,IAAI,UAAU,CAAC,CACjC,KAAK,CAAE,MAAM,CACb,MAAM,CAAE,MAAM,AAClB,CAAC,AACD,KAAK,eAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,AACf,CAAC;AClaJ,GAAG,cAAC,CAAC,AACE,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,iBAAiB,CAAE,SAAS,CAC5B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,AACf,CAAC;ACPJ,GAAG,eAAC,CAAC,AACE,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CAEZ,iBAAiB,CAAE,SAAS,CAC5B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,AACf,CAAC,AACD,KAAK,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,AACf,CAAC;ACJJ,GAAG,eAAC,CAAC,AACE,gBAAgB,CAAE,IAAI,CACtB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,iBAAiB,CAAE,SAAS,CAC5B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,AACf,CAAC;ACfJ,GAAG,eAAC,CAAC,AACE,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CAEZ,iBAAiB,CAAE,SAAS,CAC5B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,AACf,CAAC,AACD,KAAK,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,AACf,CAAC;ACNJ,GAAG,cAAC,CAAC,AACE,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,iBAAiB,CAAE,SAAS,CAC5B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,AACf,CAAC"
}